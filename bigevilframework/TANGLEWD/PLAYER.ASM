;==============================================================
;   TANGLEWOOD - A game by Matt Phillips - (c) 2014
;==============================================================
;   http://www.bigevilcorporation.co.uk
;==============================================================
;   player.asm - Player specific movement and mechanics
;==============================================================

; ************************************
; Constants
; ************************************
Player_MaxGameObjs equ 0x1

; Player dimensions
Player1Width	  equ 0x0028
Player1Height	  equ 0x0028

; Player starting positions - TODO: From spawn point
Player1StartPosScreenX equ (screen_width/2)-(Player1Width/2)
Player1StartPosScreenY equ GroundHeightScreen-Player1Height-0x80
;Player1StartPosScreenY equ (screen_height/2)-(Player1Height/2)
;Player1StartPosScreenY equ ScrollPlaneBorderY+0x20
Player1StartPosWorldX  equ Player1StartPosScreenX*SubpixelsPerPixel
Player1StartPosWorldY  equ Player1StartPosScreenY*SubpixelsPerPixel

; Player movement (all values must be divisors of SubpixelsPerPixel)
Player1MaxVelXWalk equ 0x0100 ; Player 1 max X walking velocity
Player1MaxVelXRun  equ 0x0300 ; Player 1 max X running velocity
Player1MaxVelYUp   equ 0x0600 ; Player 1 max Y velocity up
Player1MaxVelYDown equ 0x0600 ; Player 1 max Y velocity down
Player1AccelWalk   equ 0x0004 ; Player 1 walking acceleration
Player1AccelRun    equ 0x0008 ; Player 1 running acceleration
Player1DecelIdle   equ 0x0010 ; Player 1 deceleration if left alone
Player1DecelForced equ 0x0020 ; Player 1 deceleration if input opposite direction
Player1JumpVel	   equ 0x0600 ; Player 1 jump velocity impulse
Player1JumpCancelVel equ 0x0100 ; Player 1 velocity to cancel jump
Player1MaxGrabUpVel  equ 0x0300 ; Max up velocity player can grab a ledge (no limit on down vel)

; Player collision probes
Player1StepHeight	equ 0x3
Player1ProbeFloorX  equ (Player1Width/2)  ; Floor detection probe position X
Player1ProbeFloorY  equ (Player1Height-Player1StepHeight)   ; Floor detection probe position Y
Player1ProbeFloorLen equ Player1StepHeight*2  ; Floor probe length (multiplied by Y velocity)
Player1ProbeLedgeX  equ 0x1F			  ; Ledge detection probe position X
Player1ProbeLedgeY  equ 0x02			  ; Ledge detection probe position Y

; Player colour change
Player1ColourChangeSpeed equ 0x0030

; TEMP
Player1PushBorder equ 0xA*SubpixelsPerPixel

; ************************************
; Struct
; ************************************
	rsset (Character_Struct_Size)
;--------------------------
Player_Colour        rs.b 1
;--------------------------
Player_Struct_Pad    rs.b 3
Player_Struct_Size   rs.b 0

; ************************************
; Subroutines
; ************************************
PlayerInit:
	; Base functionality
	jsr CharacterInit

	; Setup default state
	move.b  #ColourYellow, Player_Colour(a0)

	; Setup default character animations
	move.l a0, a2
	add.l  #Character_Animations, a2

	; Idle
	move.l a2, a3
	add.l  #(CharacterAnim_Struct_Size*CharacterAnimIdx_Idle), a3
	move.l #Anim_NymnIdle, CharacterAnim_Addr(a3)
	move.b #Anim_NymnIdle_Speed, CharacterAnim_Speed(a3)
	move.b #Anim_NymnIdle_SizeB, CharacterAnim_Length(a3)
	move.b #0x1, CharacterAnim_Looping(a3)
	
	; Run
	move.l a2, a3
	add.l  #(CharacterAnim_Struct_Size*CharacterAnimIdx_Run), a3
	move.l #Anim_NymnRun, CharacterAnim_Addr(a3)
	move.b #Anim_NymnRun_Speed, CharacterAnim_Speed(a3)
	move.b #Anim_NymnRun_SizeB, CharacterAnim_Length(a3)
	move.b #0x1, CharacterAnim_Looping(a3)

	; Walk
	move.l a2, a3
	add.l  #(CharacterAnim_Struct_Size*CharacterAnimIdx_Walk), a3
	move.l #Anim_NymnWalk, CharacterAnim_Addr(a3)
	move.b #Anim_NymnWalk_Speed, CharacterAnim_Speed(a3)
	move.b #Anim_NymnWalk_SizeB, CharacterAnim_Length(a3)
	move.b #0x1, CharacterAnim_Looping(a3)

	; Jump
	move.l a2, a3
	add.l  #(CharacterAnim_Struct_Size*CharacterAnimIdx_Jump), a3
	move.l #Anim_NymnJump, CharacterAnim_Addr(a3)
	move.b #Anim_NymnJump_Speed, CharacterAnim_Speed(a3)
	move.b #Anim_NymnJump_SizeB, CharacterAnim_Length(a3)
	move.b #0x1, CharacterAnim_Looping(a3)

	; Hang
	move.l a2, a3
	add.l  #(CharacterAnim_Struct_Size*CharacterAnimIdx_Hang), a3
	move.l #Anim_NymnHang, CharacterAnim_Addr(a3)
	move.b #Anim_NymnHang_Speed, CharacterAnim_Speed(a3)
	move.b #Anim_NymnHang_SizeB, CharacterAnim_Length(a3)
	move.b #0x1, CharacterAnim_Looping(a3)

	; Push
	move.l a2, a3
	add.l  #(CharacterAnim_Struct_Size*CharacterAnimIdx_Push), a3
	move.l #Anim_NymnPush, CharacterAnim_Addr(a3)
	move.b #Anim_NymnPush_Speed, CharacterAnim_Speed(a3)
	move.b #Anim_NymnPush_SizeB, CharacterAnim_Length(a3)
	move.b #0x1, CharacterAnim_Looping(a3)

	rts

PlayerUpdate:
	; a0 --- GameObj addr
	; a1 --- Level addr
	
	; Base functionality
	jsr CharacterUpdate

	; Interaction
	jsr PlayerInteract_Fuzzls
	jsr PlayerInteract_Obstacles
	jsr PlayerInteract_Fireflies
	
	rts

PlayerDraw:
	; a0 --- GameObj addr
	; a1 --- Level addr
	
	; Base functionality
	jsr CharacterDraw
	
	rts

PlayerBeginColourSwitch:
	; a0 --- Character address
	
	movem.l d0/d3, -(sp)
	move.l  a0, -(sp)

	lea    SwitchingPalettesP1, a1	; Get palette array	
	clr.l  d0
	move.b Player_Colour(a0), d0	; Get colour type
	mulu   #size_address, d0		; To offset
	add.l  d0, a1					
	move.l (a1), a0					; Get new palette address
	move.l #PaletteId_Player, d0	; Get destination palette ID - TODO: From GameObj
	move.l #Player1ColourChangeSpeed, d1	; Get switch speed - TODO: From Character
	move.b #0x0, d2					; Range min
	move.b #0xE, d3					; Range max
	jsr    PaletteLerpStart			; Begin palette lerp
	
	move.l  (sp)+, a0
	movem.l (sp)+, d0/d3
	
	; Start animation
	move.l #Anim_NymnSwitch, AnimObj_AnimDataAddr(a0)
	move.l #0x0, AnimObj_AnimSubframe(a0)
	move.b #Anim_NymnSwitch_Speed, AnimObj_AnimSpeed(a0)
	move.b #Anim_NymnSwitch_SizeB, AnimObj_AnimLength(a0)
	move.b #0x1, AnimObj_Playing(a0)
	move.b #0x0, AnimObj_Looping(a0)
	
	rts

;==============================================================
; Player interaction routines
;==============================================================

PlayerInteract_Fuzzls:
	; a0 --- GameObj addr
	; a1 --- Level addr
	
	move.l a1, -(sp)
	
	; Not pushing by default
	move.b #0x0, Character_Pushing(a0)
	
	; Character must be interacting
	move.b Character_Interacting(a0), d0
	cmp.b  #0x0, d0
	beq    @NotInteracting
	
	; Character must be close to floor to interact with a Fuzzl
	move.b GameObj_CloseToFloor(a0), d0
	cmp.b  #0x0, d0
	beq    @PlayerOffFloor
	
	; Check all Fuzzls
	move.l #GameObjArray_Fuzzls, a1
	move.l #gameobjects_Fuzzl_count-1, d6
	@FuzzlLoop:
	
	; Check if active
	move.b GameObj_Active(a1), d0
	cmp.b  #0x0, d0
	beq    @NotActive
	
	; Check if close to floor
	move.b GameObj_CloseToFloor(a1), d0
	cmp.b  #0x0, d0
	beq    @FuzzlOffFloor
	
	; Check if within bounds
	; TODO: Use interaction box size, not exact bounds
	move.l d6, -(sp)
	jsr TestGameObjBoxIntersectBox
	move.l (sp)+, d6
	
	; Result in d0
	cmp.b #0x0, d0
	beq   @NotInRange

	; In range, check if fuzzl is in its nest
	btst.b #Fuzzl_State_Home, Fuzzl_State_Bits(a1)
	bne    @Home
	
	; In range and not in a nest, check which side of Fuzzl
	move.l GameObj_WorldPosX(a0), d0	; Player X
	add.l  #(Player1Width*SubpixelsPerPixel)/2, d0 ; Player X centre
	move.l GameObj_WorldPosX(a1), d1	; Fuzzl X
	add.l  #(Fuzzl_Width*SubpixelsPerPixel)/2, d1 ; Fuzzl X centre
	move.w GameObj_VelX(a0), d2			; Player velocity X
	cmp.l  d0, d1
	bgt    @LeftOfFuzzl
	
	; On right hand side of Fuzzl, check if heading towards it
	cmp.w  #0x0, d2
	bgt    @NotPushingFuzzl
	
	; Pushing Fuzzl to the left, correct penetration
	move.l GameObj_WorldPosX(a0), d0	; Player X
	add.l  #Player1PushBorder, d0
	move.l GameObj_WorldPosX(a1), d1	; Fuzzl X
	add.l  #(Fuzzl_Width*SubpixelsPerPixel), d1 ; Fuzzl right
	cmp.l  d0, d1
	blt    @NotPenetratingLeft
	sub.l  #(Fuzzl_Width*SubpixelsPerPixel), d0
	move.l d0, GameObj_WorldPosX(a1)
	@NotPenetratingLeft:
	bra    @PushingFuzzl
	
	@LeftOfFuzzl:
	; On left hand side of Fuzzl, check if heading towards it
	cmp.w  #0x0, d2
	blt    @NotPushingFuzzl
	
	; Pushing Fuzzl to the right, correct penetration
	move.l GameObj_WorldPosX(a0), d0	; Player X
	add.l  #(Player1Width*SubpixelsPerPixel), d0 ; Player right
	sub.l  #Player1PushBorder, d0
	move.l GameObj_WorldPosX(a1), d1	; Fuzzl X
	cmp.l  d0, d1
	bgt    @NotPenetratingRight
	move.l d0, GameObj_WorldPosX(a1)
	@NotPenetratingRight:

	@PushingFuzzl:
	
	; Pushing the Fuzzl
	move.b #0x1, Character_Pushing(a0)
	bclr.b #Fuzzl_State_Initial, Fuzzl_State_Bits(a1)
	bset.b #Fuzzl_State_Rolling, Fuzzl_State_Bits(a1)
	
	; Set its velocity to match
	move.w d2, GameObj_VelX(a1)
	
	bra @End
	
	@Home:
	; Check if fuzzl still has its colour
	move.b Fuzzl_Colour(a1), d0
	cmp.b  #ColourDrained, d0
	beq    @NoColour
	
	; Check if Fuzzl's colour matches player
	move.b Player_Colour(a0), d1
	cmp.b  d0, d1
	beq    @NoColourMatch
	
	; Fuzzl is home, is in range, and has its colour - take its colour
	; TODO: Compare colour, choose correct palette
	move.b d0, Player_Colour(a0)
	jsr PlayerBeginColourSwitch
	
	bra @End

	@NotInRange:
	@FuzzlOffFloor:
	@NotPushingFuzzl:
	@NotActive:
	@NoColour:
	@NoColourMatch:
	
	; Next Fuzzl
	add.l #Fuzzl_Struct_Size, a1
	dbra d6, @FuzzlLoop
	
	@NotInteracting:
	@PlayerOffFloor:
	@End:
	
	move.l (sp)+, a1
	
	rts
	
PlayerInteract_Obstacles:
	; a0 --- GameObj addr
	; a1 --- Level addr
	
	move.l a1, -(sp)

	move.w #gameobjects_obstacle_count, d0	; TODO: Count from level info
	cmp.w  #0x0, d0
	beq    @NoObstacles
	
	; Check all obstacles
	move.l #GameObjArray_Obstacles, a1
	move.l #gameobjects_Obstacle_count-1, d6
	@ObstacleLoop:
	
	; Check if solid
	move.b GameObj_Solid(a1), d0
	cmp.b  #0x0, d0
	beq    @ObstacleOpen
	
	; Block player
	; TODO: Use interaction radius
	; TODO: Move to physics solids checking
	move.l d6, -(sp)
	jsr TestGameObjBoxIntersectBox
	move.l (sp)+, d6
	
	; Result in d0
	cmp.b #0x0, d0
	beq   @NotInRange

	; Check which side of obstacle
	move.l GameObj_WorldPosX(a0), d0	; Player X
	add.l  #(Player1Width*SubpixelsPerPixel)/2, d0 ; Player X centre
	move.l GameObj_WorldPosX(a1), d1	; Fuzzl X
	add.l  #(Obstacle_Width*SubpixelsPerPixel)/2, d1 ; Obstacle X centre
	move.w GameObj_VelX(a0), d2			; Player velocity X
	cmp.l  d0, d1
	bgt    @LeftOfObstacle
	
	; On right hand side of obstacle, check if heading towards it
	cmp.w  #0x0, d2
	bgt    @NotPenetrating
	
	; Moving to the left, correct penetration
	move.l GameObj_WorldPosX(a0), d0	; Player X
	move.l GameObj_WorldPosX(a1), d1	; Obstacle X
	add.l  #(Obstacle_Width*SubpixelsPerPixel), d1 ; Obstacle right
	cmp.l  d0, d1
	blt    @NotPenetrating
	;sub.l  #(Obstacle_Width*SubpixelsPerPixel), d0
	;move.l d0, GameObj_WorldPosX(a1)
	move.w #0x0, GameObj_VelX(a0)
	@NotPenetratingLeft:
	bra    @NotPenetrating
	
	@LeftOfObstacle:
	; On left hand side of obstacle, check if heading towards it
	cmp.w  #0x0, d2
	blt    @NotPenetrating
	
	; Pushing Fuzzl to the right, correct penetration
	move.l GameObj_WorldPosX(a0), d0	; Player X
	add.l  #(Player1Width*SubpixelsPerPixel), d0 ; Player right
	move.l GameObj_WorldPosX(a1), d1	; Obstacle X
	cmp.l  d0, d1
	bgt    @NotPenetratingRight
	;move.l d0, GameObj_WorldPosX(a1)
	move.w #0x0, GameObj_VelX(a0)
	@NotPenetratingRight:

	@NotPenetrating:
	
	; Check if character is interacting
	move.b Character_Interacting(a0), d0
	cmp.b  #0x0, d0
	beq    @NotInteracting
	
	; Check if character is close to floor
	move.b GameObj_CloseToFloor(a0), d0
	cmp.b  #0x0, d0
	beq    @PlayerOffFloor
	
	; Check if the correct colour
	move.b Player_Colour(a0), d0
	move.b Obstacle_Colour(a1), d1
	cmp.b  d0, d1
	bne    @WrongColour
	
	; Success, open this blocker up
	move.b #0x0, GameObj_Solid(a1)
	move.b #0x0, GameObj_Visible(a1)	; TODO: Unblock animation
	
	; but it costs the character its colour
	move.b #ColourDrained, Player_Colour(a0)
	jsr PlayerBeginColourSwitch
	
	@ObstacleOpen:
	@NotInRange:
	@WrongColour:
	@NotInteracting:
	@PlayerOffFloor:
	
	; Next obstacle
	add.l #Obstacle_Struct_Size, a1
	dbra d6, @ObstacleLoop

	move.l (sp)+, a1

	@NoObstacles:
	
	rts

PlayerInteract_Fireflies:

	; a0 --- GameObj addr
	; a1 --- Level addr

	move.l a0, -(sp)
	move.l a1, -(sp)

	; Check player against all Fireflies in level
	move.l a0, a1						; Player in a1
	move.l #GameObjArray_Fireflies, a0	; Firefly in a0
	move.l #gameobjects_Firefly_count-1, d0	; TODO: Count from level info
	@FireflyLoop:
	movem.l d0-d1/a0-a1, -(sp)
	jsr FireflyTestObj
	movem.l (sp)+, d0-d1/a0-a1
	add.l  #Firefly_Struct_Size, a0
	dbra   d0, @FireflyLoop

	move.l (sp)+, a1
	move.l (sp)+, a0

	rts
